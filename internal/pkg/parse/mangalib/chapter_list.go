package mangalib

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"

	"github.com/PuerkitoBio/goquery"
	"github.com/google/uuid"
	"github.com/pkg/errors"

	"github.com/whitewolf185/mangaparser/internal/config"
)

// UrlGetter интерфейс для получения url для парсинга
//
//go:generate mockgen -destination=./mock/url_getter_mock.go -package=mock github.com/whitewolf185/mangaparser/internal/pkg/parse/mangalib UrlGetter
type UrlGetter interface {
	GetUrlByID(ctx context.Context, mangaID uuid.UUID, sourceType config.MangaSourceType) (string, error)
}

type chapterListStruct struct {
	Number string `json:"chapter_number"`
	Volume int	  `json:"chapter_volume"`
}

// GetChapterListUrl получает список url глав
func (mlc mangaLibController) GetChapterListUrl(ctx context.Context, mangaID uuid.UUID) ([]string, error) {
	mainMangaUrl, err := mlc.urlGetter.GetUrlByID(ctx, mangaID, config.MangaLib)
	if err != nil{
		return nil, errors.Wrap(err, "cannot get main manga url with chapter list")
	}

	res, err := http.Get(mainMangaUrl)
	if err != nil {
		return nil, errors.Wrap(err, "chapter list http get failure")
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		return nil, errors.Wrap(err, "chapter list http get failure: status is not 200")
	}

	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		return nil, errors.Wrap(err, "parsing into goquery failure")
	}

	mangaName := mlc.getMangaName(mainMangaUrl)
	chapterList, err := mlc.getChapterListFromBody(doc)
	if err != nil {
		return nil, errors.Wrap(err, "getting chapter list failure")
	}

	result := make([]string, 0, len(chapterList))
	for _, chapter := range chapterList {
		result = append(result, fmt.Sprintf("https://mangalib.me/%s/v%d/c%s", mangaName, chapter.Volume, chapter.Number))
	}

	return result, nil
}

// to marshal scruct
type autoGenerated struct {
	Chapters chapters `json:"chapters"`
}
type chapters struct {
	List []chapterListStruct `json:"list"`
}
// to marshal struct end
func (mlc mangaLibController) getChapterListFromBody(doc *goquery.Document) ([]chapterListStruct, error) {
	chapterInfo := doc.Find("script").Text()
	indexToSlice := strings.Index(chapterInfo, "window._SITE_COLOR_")
	chapterInfo = chapterInfo[:indexToSlice]
	chapterInfo = strings.ReplaceAll(chapterInfo, "window.__DATA__ = ", "")
	chapterInfo = strings.ReplaceAll(chapterInfo, "\n", "")
	chapterInfo = strings.ReplaceAll(chapterInfo, "\t", "")
	chapterInfo = strings.ReplaceAll(chapterInfo, " ", "")
	chapterInfo = chapterInfo[:len(chapterInfo)-1]

	var parsedChaptersInfo autoGenerated
	err := json.Unmarshal([]byte(chapterInfo), &parsedChaptersInfo)
	if err != nil {
		return nil, errors.Wrap(err, "unmarshal chapter info error")
	}

	sort.Slice(parsedChaptersInfo.Chapters.List, func(i, j int) bool {
		lhs, _ := strconv.ParseFloat(parsedChaptersInfo.Chapters.List[i].Number, 32)
		rhs, _ := strconv.ParseFloat(parsedChaptersInfo.Chapters.List[j].Number, 32)
		return lhs < rhs
	})

	return parsedChaptersInfo.Chapters.List, nil
}